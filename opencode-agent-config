#!/usr/bin/env node

/**
 * Oh My Opencode Agent Configuration Tool
 * Interactive CLI for managing agent model assignments
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { execSync } = require('child_process');

// ANSI color codes
const colors = {
  reset: '\x1b[0m',
  cyan: '\x1b[36m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  gray: '\x1b[90m'
};

// Validate HOME environment variable
if (!process.env.HOME) {
  console.error('Error: HOME environment variable is not set.');
  console.error('This tool requires HOME to be defined to locate configuration files.');
  process.exit(1);
}

// Configuration paths
const CONFIG_DIR = path.join(process.env.HOME, '.config', 'opencode');
const CONFIG_FILE = path.join(CONFIG_DIR, 'oh-my-opencode.json');
const BACKUP_DIR = path.join(CONFIG_DIR, 'backups');
const CONFIGS_DIR = path.join(CONFIG_DIR, 'configs');
const ACTIVE_CONFIG_FILE = path.join(CONFIG_DIR, 'active-config.json');

// Default agent configurations
// Based on Oh My Opencode defaults: https://github.com/code-yeongyu/oh-my-opencode
const DEFAULTS = {
  "google_auth": false,
  "agents": {
    "oracle": {
      "model": "openai/gpt-5.2"
    },
    "Sisyphus": {
      "model": "anthropic/claude-opus-4-5"
    },
    "librarian": {
      "model": "anthropic/claude-sonnet-4-5"
    },
    "explore": {
      "model": "opencode/grok-code"
    },
    "frontend-ui-ux-engineer": {
      "model": "google/gemini-3-pro-preview"
    },
    "document-writer": {
      "model": "google/gemini-3-pro-preview"
    },
    "multimodal-looker": {
      "model": "google/gemini-3-flash"
    }
  },
  "mcps": {
    "websearch_exa": {
      "url": "https://mcp.exa.ai/mcp?exaApiKey=4bfbfbd6-a907-4f05-98ca-cf6206af4eba&tools=web_search_exa,get_code_context_exa,crawling_exa,company_research_exa,linkedin_search_exa,deep_researcher_start,deep_researcher_check",
      "type": "remote",
      "enabled": true
    },
    "grep_app": {
      "url": "https://mcp.grep.app",
      "type": "remote"
    }
  }
};

// Configuration Manager
class ConfigurationManager {
  constructor() {
    this.ensureDirectories();
  }

  ensureDirectories() {
    if (!fs.existsSync(CONFIGS_DIR)) {
      fs.mkdirSync(CONFIGS_DIR, { recursive: true });
    }
    if (!fs.existsSync(BACKUP_DIR)) {
      fs.mkdirSync(BACKUP_DIR, { recursive: true });
    }
  }

  validateConfigName(name) {
    if (!name || typeof name !== 'string') return false;
    // Allow alphanumeric, hyphens, underscores
    return /^[a-z0-9-_]+$/i.test(name);
  }

  getConfigPath(name) {
    return path.join(CONFIGS_DIR, `${name}.json`);
  }

  listConfigurations() {
    try {
      const files = fs.readdirSync(CONFIGS_DIR)
        .filter(f => f.endsWith('.json'))
        .map(f => f.replace('.json', ''));
      return files;
    } catch (error) {
      return [];
    }
  }

  configExists(name) {
    return fs.existsSync(this.getConfigPath(name));
  }

  loadConfiguration(name) {
    const configPath = this.getConfigPath(name);
    try {
      const data = fs.readFileSync(configPath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      if (error.code === 'ENOENT') {
        throw new Error(`Configuration "${name}" not found at ${configPath}`);
      } else if (error instanceof SyntaxError) {
        throw new Error(`Configuration "${name}" has invalid JSON. Check ${configPath} for syntax errors.`);
      }
      throw new Error(`Failed to load configuration "${name}": ${error.message}`);
    }
  }

  saveConfiguration(name, description, config) {
    if (!this.validateConfigName(name)) {
      throw new Error('Invalid configuration name. Use only letters, numbers, hyphens, and underscores.');
    }

    const configPath = this.getConfigPath(name);
    const now = new Date().toISOString();
    
    let metadata = {
      name,
      description,
      created: now,
      modified: now,
      config
    };

    // Preserve creation timestamp if config exists
    if (fs.existsSync(configPath)) {
      try {
        const existing = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        if (existing.created) {
          metadata.created = existing.created;
        }
      } catch (e) {
        // Ignore, will use new timestamp
      }
    }

    fs.writeFileSync(configPath, JSON.stringify(metadata, null, 2));
    return metadata;
  }

  deleteConfiguration(name) {
    const configPath = this.getConfigPath(name);
    if (!fs.existsSync(configPath)) {
      throw new Error(`Configuration "${name}" does not exist`);
    }
    fs.unlinkSync(configPath);
  }

  renameConfiguration(oldName, newName) {
    if (!this.validateConfigName(newName)) {
      throw new Error('Invalid configuration name. Use only letters, numbers, hyphens, and underscores.');
    }

    const oldPath = this.getConfigPath(oldName);
    const newPath = this.getConfigPath(newName);

    if (!fs.existsSync(oldPath)) {
      throw new Error(`Configuration "${oldName}" does not exist`);
    }

    if (fs.existsSync(newPath)) {
      throw new Error(`Configuration "${newName}" already exists`);
    }

    // Update name in metadata
    const metadata = JSON.parse(fs.readFileSync(oldPath, 'utf8'));
    metadata.name = newName;
    metadata.modified = new Date().toISOString();
    
    fs.writeFileSync(newPath, JSON.stringify(metadata, null, 2));
    fs.unlinkSync(oldPath);
  }

  getActiveConfig() {
    try {
      if (fs.existsSync(ACTIVE_CONFIG_FILE)) {
        const data = JSON.parse(fs.readFileSync(ACTIVE_CONFIG_FILE, 'utf8'));
        return data.active;
      }
    } catch (error) {
      // Fall through to default
    }
    return null;
  }

  setActiveConfig(name) {
    fs.writeFileSync(ACTIVE_CONFIG_FILE, JSON.stringify({ active: name }, null, 2));
  }

  updateMainConfigFile(config) {
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));
  }

  migrateIfNeeded() {
    this.ensureDirectories();
    
    // Check if migration already done
    if (this.listConfigurations().length > 0) {
      return false;
    }

    console.log('\nFirst-time setup: migrating to configuration profiles...\n');

    // Create omo-default from DEFAULTS
    this.saveConfiguration('omo-default', 'Oh My Opencode default configuration', DEFAULTS);

    // Migrate existing config if it exists
    if (fs.existsSync(CONFIG_FILE)) {
      try {
        const existing = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));
        this.saveConfiguration('user-config', 'Migrated user configuration', existing);
        this.setActiveConfig('user-config');
        console.log('✓ Migrated existing configuration to "user-config"');
      } catch (error) {
        console.error('Warning: Could not migrate existing config, using defaults');
        this.setActiveConfig('omo-default');
      }
    } else {
      this.setActiveConfig('omo-default');
    }

    console.log('✓ Created "omo-default" configuration');
    console.log('✓ Migration complete\n');
    return true;
  }

  exportConfiguration(name, destPath) {
    const metadata = this.loadConfiguration(name);
    fs.writeFileSync(destPath, JSON.stringify(metadata, null, 2));
  }

  importConfiguration(sourcePath, name, description) {
    const data = JSON.parse(fs.readFileSync(sourcePath, 'utf8'));
    
    // Handle both wrapped and unwrapped formats
    const config = data.config || data;
    const desc = description || data.description || 'Imported configuration';
    
    this.saveConfiguration(name, desc, config);
  }
}

// Agent characteristics for recommendations
// Agent profiles based on Oh My Opencode's actual agent purposes
// See: https://github.com/code-yeongyu/oh-my-opencode/blob/dev/src/agents/AGENTS.md
const AGENT_PROFILES = {
  "oracle": {
    description: "Architecture decisions, debugging, code review (GPT-5.2 class)",
    preferred: ["reasoning", "large_context"],
    minContext: 128000
  },
  "Sisyphus": {
    description: "Primary orchestrator with extended thinking (Opus class)",
    preferred: ["reasoning", "thinking", "large_context"],
    minContext: 128000
  },
  "librarian": {
    description: "Multi-repo research, docs, GitHub examples (Sonnet class)",
    preferred: ["reasoning", "large_context"],
    minContext: 128000
  },
  "explore": {
    description: "Fast contextual grep for codebase exploration (Grok/Flash class)",
    preferred: ["fast", "large_context"],
    minContext: 64000
  },
  "frontend-ui-ux-engineer": {
    description: "UI/UX code generation with visual understanding (Gemini Pro class)",
    preferred: ["reasoning", "multimodal", "image_input"],
    minContext: 64000
  },
  "document-writer": {
    description: "Technical documentation and writing (Gemini Pro class)",
    preferred: ["reasoning", "text_output", "large_context"],
    minContext: 64000
  },
  "multimodal-looker": {
    description: "PDF/image analysis, visual content (Flash class)",
    preferred: ["multimodal", "image_input", "pdf_input", "fast"],
    minContext: 32000
  }
};

class AgentConfigTool {
  constructor() {
    this.config = null;
    this.configName = null;
    this.configMetadata = null;
    this.models = null;
    this.providers = [];
    this.configManager = new ConfigurationManager();
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
  }

  async loadConfig() {
    try {
      // Run migration if needed
      this.configManager.migrateIfNeeded();

      // Get active config name
      this.configName = this.configManager.getActiveConfig();
      if (!this.configName) {
        this.configName = 'omo-default';
        this.configManager.setActiveConfig(this.configName);
      }

      // Load configuration metadata
      this.configMetadata = this.configManager.loadConfiguration(this.configName);
      this.config = this.configMetadata.config;

      // Update main config file to match active config
      this.configManager.updateMainConfigFile(this.config);
    } catch (error) {
      console.error(`Error loading config: ${error.message}`);
      console.error('\nPossible causes:');
      console.error('  1. Configuration file is corrupted or has invalid JSON');
      console.error('  2. File permissions issue');
      console.error('\nTo fix:');
      console.error(`  - Check file permissions: ls -la ${CONFIGS_DIR}`);
      console.error(`  - Restore from backup: ls ${BACKUP_DIR}`);
      console.error('  - Delete configs dir and restart to regenerate defaults:');
      console.error(`    rm -rf ${CONFIGS_DIR} && opencode-agent-config`);
      process.exit(1);
    }
  }

  /**
   * Validate config against DEFAULTS and detect missing agents/MCPs.
   * Returns object with missing items, or null if config is up-to-date.
   */
  validateConfig() {
    const issues = {
      missingAgents: [],
      missingMcps: [],
      extraAgents: [],
      extraMcps: []
    };

    const configAgents = this.config?.agents || {};
    const configMcps = this.config?.mcps || {};
    const defaultAgents = DEFAULTS.agents || {};
    const defaultMcps = DEFAULTS.mcps || {};

    // Check for missing agents (in DEFAULTS but not in config)
    for (const agentName of Object.keys(defaultAgents)) {
      if (!configAgents[agentName]) {
        issues.missingAgents.push({
          name: agentName,
          defaultModel: defaultAgents[agentName].model,
          description: AGENT_PROFILES[agentName]?.description || 'OmO built-in agent'
        });
      }
    }

    // Check for missing MCPs (in DEFAULTS but not in config)
    for (const mcpName of Object.keys(defaultMcps)) {
      if (!configMcps[mcpName]) {
        issues.missingMcps.push({
          name: mcpName,
          config: defaultMcps[mcpName]
        });
      }
    }

    // Check for extra agents (in config but not in DEFAULTS - could be deprecated or custom)
    for (const agentName of Object.keys(configAgents)) {
      if (!defaultAgents[agentName]) {
        issues.extraAgents.push({
          name: agentName,
          model: configAgents[agentName].model
        });
      }
    }

    // Check for extra MCPs (in config but not in DEFAULTS)
    for (const mcpName of Object.keys(configMcps)) {
      if (!defaultMcps[mcpName]) {
        issues.extraMcps.push({
          name: mcpName
        });
      }
    }

    const hasIssues = issues.missingAgents.length > 0 || 
                      issues.missingMcps.length > 0 ||
                      issues.extraAgents.length > 0 ||
                      issues.extraMcps.length > 0;

    return hasIssues ? issues : null;
  }

  /**
   * Show validation issues and offer to sync config with DEFAULTS.
   * Called after loadConfig in interactive mode.
   */
  async promptConfigSync() {
    const issues = this.validateConfig();
    if (!issues) return;

    console.log(`\n${'='.repeat(70)}`);
    console.log(`${colors.yellow}⚠ Configuration Sync Available${colors.reset}`);
    console.log(`${'='.repeat(70)}\n`);

    console.log('Your configuration differs from the latest OmO defaults.\n');

    // Show missing agents
    if (issues.missingAgents.length > 0) {
      console.log(`${colors.cyan}NEW AGENTS available:${colors.reset}`);
      for (const agent of issues.missingAgents) {
        console.log(`  + ${colors.green}${agent.name}${colors.reset}`);
        console.log(`    ${agent.description}`);
        console.log(`    Default model: ${agent.defaultModel}\n`);
      }
    }

    // Show missing MCPs
    if (issues.missingMcps.length > 0) {
      console.log(`${colors.cyan}NEW MCPs available:${colors.reset}`);
      for (const mcp of issues.missingMcps) {
        console.log(`  + ${colors.green}${mcp.name}${colors.reset}`);
        console.log(`    Type: ${mcp.config.type || 'unknown'}\n`);
      }
    }

    // Show extra agents (informational - won't remove)
    if (issues.extraAgents.length > 0) {
      console.log(`${colors.dim}EXTRA agents in your config (not in defaults):${colors.reset}`);
      for (const agent of issues.extraAgents) {
        console.log(`  ? ${agent.name} → ${agent.model}`);
      }
      console.log(`  ${colors.dim}(These will be kept - may be custom or deprecated)${colors.reset}\n`);
    }

    // Show extra MCPs (informational)
    if (issues.extraMcps.length > 0) {
      console.log(`${colors.dim}EXTRA MCPs in your config (not in defaults):${colors.reset}`);
      for (const mcp of issues.extraMcps) {
        console.log(`  ? ${mcp.name}`);
      }
      console.log(`  ${colors.dim}(These will be kept)${colors.reset}\n`);
    }

    // Offer to sync
    if (issues.missingAgents.length > 0 || issues.missingMcps.length > 0) {
      console.log('Options:');
      console.log('  [A] Add all missing agents and MCPs');
      console.log('  [S] Select which to add');
      console.log('  [N] Skip for now\n');

      const choice = await this.prompt('Choose option: ');

      switch (choice.toLowerCase()) {
        case 'a':
          await this.addAllMissing(issues);
          break;
        case 's':
          await this.selectiveSync(issues);
          break;
        case 'n':
        default:
          console.log('\nSkipped. You can sync later from the main menu.\n');
          break;
      }
    } else {
      await this.prompt('Press Enter to continue...');
    }
  }

  /**
   * Add all missing agents and MCPs to config.
   */
  async addAllMissing(issues) {
    let added = 0;

    // Add missing agents
    if (!this.config.agents) this.config.agents = {};
    for (const agent of issues.missingAgents) {
      this.config.agents[agent.name] = { model: agent.defaultModel };
      added++;
    }

    // Add missing MCPs
    if (!this.config.mcps) this.config.mcps = {};
    for (const mcp of issues.missingMcps) {
      this.config.mcps[mcp.name] = mcp.config;
      added++;
    }

    if (added > 0) {
      this.saveConfig();
      console.log(`\n${colors.green}✓ Added ${added} items to configuration.${colors.reset}\n`);
    }
  }

  /**
   * Let user select which missing items to add.
   */
  async selectiveSync(issues) {
    let added = 0;

    // Agents
    if (issues.missingAgents.length > 0) {
      console.log('\n--- Missing Agents ---\n');
      for (const agent of issues.missingAgents) {
        const answer = await this.prompt(`Add ${agent.name}? (${agent.defaultModel}) [Y/n]: `);
        if (answer.toLowerCase() !== 'n') {
          if (!this.config.agents) this.config.agents = {};
          this.config.agents[agent.name] = { model: agent.defaultModel };
          added++;
          console.log(`  ${colors.green}✓ Added ${agent.name}${colors.reset}`);
        }
      }
    }

    // MCPs
    if (issues.missingMcps.length > 0) {
      console.log('\n--- Missing MCPs ---\n');
      for (const mcp of issues.missingMcps) {
        const answer = await this.prompt(`Add ${mcp.name}? [Y/n]: `);
        if (answer.toLowerCase() !== 'n') {
          if (!this.config.mcps) this.config.mcps = {};
          this.config.mcps[mcp.name] = mcp.config;
          added++;
          console.log(`  ${colors.green}✓ Added ${mcp.name}${colors.reset}`);
        }
      }
    }

    if (added > 0) {
      this.saveConfig();
      console.log(`\n${colors.green}✓ Added ${added} items to configuration.${colors.reset}\n`);
    } else {
      console.log('\nNo changes made.\n');
    }
  }

  async loadModels() {
    try {
      process.stdout.write('Loading available models');
      
      // Check if opencode command exists
      let output;
      try {
        output = execSync('opencode models --verbose 2>/dev/null', { encoding: 'utf8' });
      } catch (execError) {
        console.log('\n');
        console.error('Error: Failed to run "opencode models" command.');
        console.error('\nPossible causes:');
        console.error('  1. OpenCode is not installed');
        console.error('  2. OpenCode is not in your PATH');
        console.error('  3. OpenCode configuration issue');
        console.error('\nTo fix:');
        console.error('  - Install OpenCode: npm install -g opencode-ai');
        console.error('  - Verify installation: opencode --version');
        console.error('  - Check PATH includes OpenCode location');
        process.exit(1);
      }
      
      process.stdout.write('... parsing');
      this.models = this.parseModels(output);
      this.extractProviders();
      console.log(` ✓\nLoaded ${this.models.length} models from ${this.providers.length} providers\n`);
    } catch (error) {
      console.error(`\nError loading models: ${error.message}`);
      process.exit(1);
    }
  }

  parseModels(output) {
    const models = [];
    const lines = output.split('\n');
    let currentModel = null;
    let jsonBuffer = '';
    let braceCount = 0;

    for (const line of lines) {
      if (line.match(/^[a-z0-9-]+\/[a-z0-9-.:/]+$/i) && braceCount === 0) {
        currentModel = line.trim();
        jsonBuffer = '';
      } else if (currentModel) {
        // Count braces to handle nested objects
        const openBraces = (line.match(/{/g) || []).length;
        const closeBraces = (line.match(/}/g) || []).length;
        braceCount += openBraces - closeBraces;
        
        jsonBuffer += (jsonBuffer ? '\n' : '') + line;
        
        if (braceCount === 0 && jsonBuffer) {
          try {
            const modelData = JSON.parse(jsonBuffer);
            models.push({
              id: currentModel,
              ...modelData
            });
          } catch (e) {
            // Skip malformed JSON
          }
          currentModel = null;
          jsonBuffer = '';
        }
      }
    }

    return models;
  }

  extractProviders() {
    const providerSet = new Set();
    this.models.forEach(model => {
      // Use providerID from model data, fall back to splitting ID if not present
      const provider = model.providerID || model.id.split('/')[0];
      if (provider) {
        providerSet.add(provider);
      }
    });
    this.providers = Array.from(providerSet).sort();
  }

  /**
   * Score a model for a given agent type.
   * 
   * Scoring logic:
   * - Base context score: Graduated based on how well it meets minContext
   * - Preferred capabilities: Bonus points for each matching preference
   * - Provider preference: Bonus for preferred providers
   * - Penalty: Models that don't meet minimum context get negative score
   */
  scoreModel(model, agentType) {
    const profile = AGENT_PROFILES[agentType];
    if (!profile) return 0;

    let score = 0;
    const caps = model.capabilities || {};
    const context = model.limit?.context || 0;
    const minContext = profile.minContext || 32000;

    // Context window scoring (graduated, not binary)
    if (context >= minContext) {
      // Base points for meeting minimum
      score += 10;
      // Bonus for exceeding minimum (up to +10 more)
      const contextRatio = Math.min(context / minContext, 4); // Cap at 4x
      score += Math.floor((contextRatio - 1) * 3.33); // +3.33 per multiple
    } else {
      // Penalty for not meeting minimum context
      const deficit = (minContext - context) / minContext;
      score -= Math.floor(deficit * 20); // Up to -20 for severely undersized
    }

    // Capability scoring with improved detection
    for (const pref of profile.preferred) {
      switch (pref) {
        case "reasoning":
          // Check explicit reasoning capability OR extended thinking
          if (caps.reasoning) {
            score += 15;
          } else if (this.hasExtendedThinking(model)) {
            // Extended thinking models are reasoning-capable even if API says false
            score += 15;
          }
          break;

        case "thinking":
          // Extended thinking detection (better than name-based)
          if (this.hasExtendedThinking(model)) {
            score += 12;
          } else if (model.name?.toLowerCase().includes('thinking') || 
                     model.id?.toLowerCase().includes('thinking')) {
            // Fallback to name-based detection
            score += 10;
          }
          break;

        case "large_context":
          // Graduated scoring for large context
          if (context >= 500000) score += 12;      // 500K+
          else if (context >= 200000) score += 8;  // 200K+
          else if (context >= 128000) score += 4;  // 128K+
          break;

        case "multimodal":
          // Full multimodal (image + pdf) gets more points
          const hasImage = caps.input?.image;
          const hasPdf = caps.input?.pdf;
          const hasVideo = caps.input?.video;
          if (hasImage && hasPdf) score += 15;
          else if (hasImage || hasPdf) score += 10;
          if (hasVideo) score += 3; // Bonus for video
          break;

        case "image_input":
          if (caps.input?.image) score += 12;
          break;

        case "pdf_input":
          if (caps.input?.pdf) score += 8;
          break;

        case "fast":
          // Use cost as proxy for speed (lower cost = faster/cheaper model)
          // Also check name patterns
          if (this.isFastModel(model)) score += 10;
          break;

        case "text_output":
          if (caps.output?.text) score += 5;
          break;
      }
    }

    // Preferred provider bonus
    const preferredProviders = this.config?.preferred_providers || [];
    if (preferredProviders.length > 0) {
      const provider = model.providerID || model.id.split('/')[0];
      const providerIndex = preferredProviders.indexOf(provider);
      if (providerIndex !== -1) {
        // Higher bonus for providers earlier in the preference list
        score += (preferredProviders.length - providerIndex) * 5;
      }
    }

    return score;
  }

  /**
   * Check if model has extended thinking capability.
   * Extended thinking is indicated by interleaved being an object with a field property.
   */
  hasExtendedThinking(model) {
    const interleaved = model.capabilities?.interleaved;
    // If interleaved is an object with a field property, it's extended thinking
    if (interleaved && typeof interleaved === 'object' && interleaved.field) {
      return true;
    }
    return false;
  }

  /**
   * Check if model is a "fast" model (optimized for speed/cost).
   * Uses multiple heuristics: name patterns, cost, family.
   */
  isFastModel(model) {
    // Name-based patterns
    const name = (model.name || '').toLowerCase();
    const id = (model.id || '').toLowerCase();
    const family = (model.family || '').toLowerCase();
    
    const fastPatterns = ['flash', 'fast', 'mini', 'lite', 'haiku', 'instant'];
    for (const pattern of fastPatterns) {
      if (name.includes(pattern) || id.includes(pattern) || family.includes(pattern)) {
        return true;
      }
    }

    // Cost-based heuristic: if cost is very low, it's likely fast
    const cost = model.cost;
    if (cost) {
      const totalCost = (cost.input || 0) + (cost.output || 0);
      // Models with total cost < 5 are typically fast/cheap
      if (totalCost < 5 && totalCost > 0) {
        return true;
      }
    }

    return false;
  }

  getRecommendedModels(agentType, limit = 5) {
    const scored = this.models.map(model => ({
      ...model,
      score: this.scoreModel(model, agentType)
    }));

    scored.sort((a, b) => b.score - a.score);
    return scored.slice(0, limit);
  }

  createBackup() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const backupFile = path.join(BACKUP_DIR, `${this.configName}-${timestamp}.json`);
    
    try {
      const configPath = this.configManager.getConfigPath(this.configName);
      if (fs.existsSync(configPath)) {
        fs.copyFileSync(configPath, backupFile);
        console.log(`✓ Backup created: ${backupFile}\n`);
      }
      return backupFile;
    } catch (error) {
      console.error(`Error creating backup: ${error.message}`);
      console.error(`\nBackup path: ${backupFile}`);
      if (error.code === 'EACCES') {
        console.error('Permission denied. Check directory permissions:');
        console.error(`  ls -la ${BACKUP_DIR}`);
      } else if (error.code === 'ENOSPC') {
        console.error('Disk full. Free up space and try again.');
      }
      throw error;
    }
  }

  saveConfig() {
    try {
      this.createBackup();
      
      // Update metadata modified timestamp and save
      const description = this.configMetadata?.description || 'Configuration';
      this.configMetadata = this.configManager.saveConfiguration(
        this.configName,
        description,
        this.config
      );
      
      // Update main config file
      this.configManager.updateMainConfigFile(this.config);
      
      console.log('✓ Configuration saved successfully\n');
    } catch (error) {
      console.error(`Error saving config: ${error.message}`);
      console.error('\nYour changes may not have been saved.');
      console.error('The previous config should still be intact.');
      console.error(`\nTo recover, check backups: ls ${BACKUP_DIR}`);
      throw error;
    }
  }

  async restoreDefaults() {
    try {
      // Switch to omo-default configuration
      await this.switchToConfiguration('omo-default');
      console.log('✓ Switched to default configuration\n');
    } catch (error) {
      console.error(`Error restoring defaults: ${error.message}`);
    }
  }

  formatModel(model, showScore = false, score = 0) {
    const ctx = model.limit?.context ? `${Math.floor(model.limit.context / 1000)}K` : '?';
    const caps = [];
    
    // Capability indicators
    if (model.capabilities?.reasoning || this.hasExtendedThinking(model)) caps.push('R');
    if (this.hasExtendedThinking(model)) caps.push('T');  // Extended Thinking
    if (model.capabilities?.input?.image) caps.push('I');
    if (model.capabilities?.input?.pdf) caps.push('P');
    if (this.isFastModel(model)) caps.push('F');  // Fast/cheap model
    
    const capsStr = caps.length > 0 ? `[${caps.join('')}]` : '';
    
    // Get provider name
    const provider = model.providerID || model.id.split('/')[0];
    const providerStr = `${colors.cyan}${provider}${colors.reset}`;
    
    // Score display for recommendations
    const scoreStr = showScore && score > 0 ? ` ${colors.dim}(score: ${score})${colors.reset}` : '';
    
    return `${model.name || model.id} (${ctx}${capsStr}) ${providerStr}${scoreStr}`;
  }

  async prompt(question) {
    return new Promise(resolve => {
      this.rl.question(question, answer => resolve(answer.trim()));
    });
  }

  async selectModel(agentType, currentModel) {
    console.clear();
    const profile = AGENT_PROFILES[agentType];
    
    console.log(`\n${'='.repeat(70)}`);
    console.log(`Select Model for: ${agentType}`);
    console.log(`Description: ${profile?.description || 'Custom agent'}`);
    console.log(`Current: ${currentModel}`);
    if (profile) {
      console.log(`Prefers: ${profile.preferred.join(', ')} | Min context: ${Math.floor(profile.minContext / 1000)}K`);
    }
    console.log(`${'='.repeat(70)}\n`);

    const recommended = this.getRecommendedModels(agentType, 8);
    
    console.log('RECOMMENDED MODELS:\n');
    recommended.forEach((model, idx) => {
      const current = model.id === currentModel ? ' ⭐ (current)' : '';
      console.log(`  ${idx + 1}. ${this.formatModel(model, true, model.score)}${current}`);
    });

    console.log(`\n${colors.dim}Capabilities: [R]=Reasoning [T]=Thinking [I]=Image [P]=PDF [F]=Fast${colors.reset}`);
    console.log('\n[S] Search all models');
    console.log('[F] Filter by provider');
    console.log('[C] Cancel\n');

    const choice = await this.prompt('Select option: ');

    if (choice.toLowerCase() === 'c') {
      return null;
    }

    if (choice.toLowerCase() === 's') {
      return await this.searchModels(agentType, currentModel);
    }

    if (choice.toLowerCase() === 'f') {
      return await this.filterByProvider(agentType, currentModel);
    }

    const idx = parseInt(choice, 10) - 1;
    if (!isNaN(idx) && idx >= 0 && idx < recommended.length) {
      return recommended[idx].id;
    }

    console.log('Invalid choice');
    await this.prompt('Press Enter to continue...');
    return await this.selectModel(agentType, currentModel);
  }

  async searchModels(agentType, currentModel) {
    console.clear();
    console.log('\n--- Search Models ---\n');
    
    const query = await this.prompt('Search (provider/name or Enter for all): ');
    const filtered = query 
      ? this.models.filter(m => m.id.toLowerCase().includes(query.toLowerCase()) || 
                                 m.name?.toLowerCase().includes(query.toLowerCase()))
      : this.models;

    if (filtered.length === 0) {
      console.log('No models found');
      await this.prompt('Press Enter to continue...');
      return await this.selectModel(agentType, currentModel);
    }

    return await this.displayModelList(filtered, agentType, currentModel);
  }

  async filterByProvider(agentType, currentModel) {
    console.clear();
    console.log('\n--- Filter by Provider ---\n');
    
    console.log('AVAILABLE PROVIDERS:\n');
    this.providers.forEach((provider, idx) => {
      const count = this.models.filter(m => (m.providerID || m.id.split('/')[0]) === provider).length;
      console.log(`  ${idx + 1}. ${provider} (${count} models)`);
    });

    console.log('\n[A] Select All');
    console.log('[C] Cancel\n');
    
    const choice = await this.prompt('Select providers (comma-separated numbers or letters): ');
    
    if (choice.toLowerCase() === 'c') {
      return await this.selectModel(agentType, currentModel);
    }

    let selectedProviders = [];
    if (choice.toLowerCase() === 'a') {
      selectedProviders = this.providers;
    } else {
      const indices = choice.split(',').map(s => parseInt(s.trim(), 10) - 1).filter(n => !isNaN(n));
      selectedProviders = indices
        .filter(idx => idx >= 0 && idx < this.providers.length)
        .map(idx => this.providers[idx]);
    }

    if (selectedProviders.length === 0) {
      console.log('No providers selected');
      await this.prompt('Press Enter to continue...');
      return await this.filterByProvider(agentType, currentModel);
    }

    const filtered = this.models.filter(m => {
      const provider = m.providerID || m.id.split('/')[0];
      return selectedProviders.includes(provider);
    });

    return await this.displayModelList(filtered, agentType, currentModel);
  }

  async displayModelList(filtered, agentType, currentModel) {
    const perPage = 15;
    let page = 0;

    while (true) {
      console.clear();
      console.log(`\n--- Models (${filtered.length} total) - Page ${page + 1}/${Math.ceil(filtered.length / perPage)} ---\n`);

      const start = page * perPage;
      const end = Math.min(start + perPage, filtered.length);

      for (let i = start; i < end; i++) {
        const current = filtered[i].id === currentModel ? ' ⭐' : '';
        console.log(`  ${i + 1}. ${this.formatModel(filtered[i])}${current}`);
      }

      console.log('\n[N] Next page  [P] Previous page  [#] Select number  [C] Cancel\n');
      const choice = await this.prompt('Select option: ');

      if (choice.toLowerCase() === 'c') {
        return await this.selectModel(agentType, currentModel);
      }
      if (choice.toLowerCase() === 'n' && end < filtered.length) {
        page++;
        continue;
      }
      if (choice.toLowerCase() === 'p' && page > 0) {
        page--;
        continue;
      }

      const idx = parseInt(choice, 10) - 1;
      if (!isNaN(idx) && idx >= 0 && idx < filtered.length) {
        return filtered[idx].id;
      }
    }
  }

  async editAgent(agentName, fromMenu = false) {
    const currentModel = this.config.agents[agentName]?.model || 'none';
    const newModel = await this.selectModel(agentName, currentModel);

    if (newModel && newModel !== currentModel) {
      // Confirm model change
      console.log(`\nChange ${agentName} model:`);
      console.log(`  From: ${currentModel}`);
      console.log(`  To:   ${newModel}\n`);
      const confirm = await this.prompt('Confirm change? (yes/no): ');
      
      if (confirm.toLowerCase() !== 'yes' && confirm.toLowerCase() !== 'y') {
        console.log('Change cancelled');
        if (!fromMenu) {
          await this.prompt('Press Enter to continue...');
        }
        return false;
      }
      
      if (!this.config.agents[agentName]) {
        this.config.agents[agentName] = {};
      }
      this.config.agents[agentName].model = newModel;
      this.saveConfig();
      console.log(`✓ Updated ${agentName} to ${newModel}`);
      
      // Only prompt to continue if not from agent config menu
      if (!fromMenu) {
        await this.prompt('Press Enter to continue...');
      }
    }
    return newModel !== null;
  }

  async showAgentInfo() {
    console.clear();
    console.log('\n' + '='.repeat(70));
    console.log('Oh My Opencode Built-in Agents');
    console.log('='.repeat(70) + '\n');
    
    console.log('This tool manages model assignments for Oh My Opencode\'s curated agents.\n');
    console.log('AVAILABLE AGENTS:\n');
    
    Object.entries(AGENT_PROFILES).forEach(([name, profile]) => {
      console.log(`${colors.cyan}${name}${colors.reset}`);
      console.log(`  ${profile.description}`);
      console.log(`  Preferred: ${profile.preferred.join(', ')}`);
      console.log(`  Min context: ${profile.minContext.toLocaleString()} tokens\n`);
    });
    
    console.log('Note: To create custom agents with system prompts, see:');
    console.log('      docs/CUSTOM-AGENTS.md\n');
    
    await this.prompt('Press Enter to continue...');
  }

  async deleteAgent(agentName, fromMenu = false) {
    const confirm = await this.prompt(`Delete agent "${agentName}"? (yes/no): `);
    if (confirm.toLowerCase() === 'yes') {
      delete this.config.agents[agentName];
      this.saveConfig();
      console.log(`✓ Deleted agent ${agentName}`);
      
      // Only prompt to continue if not from agent config menu  
      if (!fromMenu) {
        await this.prompt('Press Enter to continue...');
      }
      return true;
    }
    return false;
  }

  async switchToConfiguration(configName) {
    if (!this.configManager.configExists(configName)) {
      throw new Error(`Configuration "${configName}" does not exist`);
    }

    this.configName = configName;
    this.configManager.setActiveConfig(configName);
    this.configMetadata = this.configManager.loadConfiguration(configName);
    this.config = this.configMetadata.config;
    this.configManager.updateMainConfigFile(this.config);
  }

  async manageConfigurationsMenu() {
    while (true) {
      console.clear();
      console.log('\n' + '='.repeat(70));
      console.log('Manage Configurations');
      console.log('='.repeat(70) + '\n');

      const configs = this.configManager.listConfigurations();
      
      console.log('AVAILABLE CONFIGURATIONS:\n');
      configs.forEach((name, idx) => {
        const active = name === this.configName ? ' [ACTIVE]' : '';
        const metadata = this.configManager.loadConfiguration(name);
        const modDate = new Date(metadata.modified).toLocaleDateString();
        const agentCount = Object.keys(metadata.config.agents || {}).length;
        console.log(`  ${idx + 1}. ${name}${active} (${agentCount} agents)`);
        console.log(`     ${metadata.description}`);
        console.log(`     Modified: ${modDate}\n`);
      });

      console.log('ACTIONS:\n');
      console.log('  [S] Switch active configuration');
      console.log('  [N] New configuration');
      console.log('  [R] Rename configuration');
      console.log('  [T] Edit description');
      console.log('  [D] Delete configuration');
      console.log('  [E] Export configuration');
      console.log('  [I] Import configuration');
      console.log('  [B] Back to main menu\n');

      const choice = await this.prompt('Select option: ');

      switch (choice.toLowerCase()) {
        case 's':
          await this.switchConfiguration();
          break;
        case 'n':
          await this.createConfiguration();
          break;
        case 'r':
          await this.renameConfiguration();
          break;
        case 't':
          await this.editDescription();
          break;
        case 'd':
          await this.deleteConfiguration();
          break;
        case 'e':
          await this.exportConfiguration();
          break;
        case 'i':
          await this.importConfiguration();
          break;
        case 'b':
          return;
        default:
          console.log('Invalid option');
          await this.prompt('Press Enter to continue...');
      }
    }
  }

  async switchConfiguration() {
    console.clear();
    console.log('\n--- Switch Configuration ---\n');
    
    const configs = this.configManager.listConfigurations();
    configs.forEach((name, idx) => {
      const active = name === this.configName ? ' [ACTIVE]' : '';
      console.log(`  ${idx + 1}. ${name}${active}`);
    });

    console.log('\n[C] Cancel\n');
    const choice = await this.prompt('Select configuration: ');

    if (choice.toLowerCase() === 'c') return;

    const idx = parseInt(choice, 10) - 1;
    if (!isNaN(idx) && idx >= 0 && idx < configs.length) {
      const configName = configs[idx];
      if (configName === this.configName) {
        console.log('Already active');
      } else {
        try {
          await this.switchToConfiguration(configName);
          console.log(`\n✓ Switched to configuration: ${configName}`);
        } catch (error) {
          console.error(`Error: ${error.message}`);
        }
      }
    } else {
      console.log('Invalid selection');
    }

    await this.prompt('Press Enter to continue...');
  }

  async createConfiguration() {
    console.clear();
    console.log('\n--- Create New Configuration ---\n');

    const name = await this.prompt('Configuration name: ');
    if (!name) return;

    if (this.configManager.configExists(name)) {
      console.log('Configuration already exists');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const description = await this.prompt('Description: ');
    
    console.log('\nCreate from:\n');
    console.log('  [1] Copy omo-default (recommended - start with OmO agents)');
    console.log('  [2] Copy from another configuration');
    console.log('  [3] Copy current configuration');
    console.log('  [4] Minimal configuration (no agents)\n');

    const choice = await this.prompt('Select option: ');
    
    let config;
    let needsSetup = false;
    let copiedFrom = null;
    
    switch (choice) {
      case '1':
        const defaultMeta = this.configManager.loadConfiguration('omo-default');
        config = JSON.parse(JSON.stringify(defaultMeta.config));
        copiedFrom = 'omo-default';
        break;
      case '2': {
        // Show list of configurations to copy from
        console.clear();
        console.log('\n--- Select Configuration to Copy ---\n');
        
        const configs = this.configManager.listConfigurations();
        configs.forEach((configName, idx) => {
          const metadata = this.configManager.loadConfiguration(configName);
          const current = configName === this.configName ? ' [CURRENT]' : '';
          console.log(`  ${idx + 1}. ${configName}${current}`);
          console.log(`     ${metadata.description}\n`);
        });
        
        console.log('[C] Cancel\n');
        const copyChoice = await this.prompt('Select configuration: ');
        
        if (copyChoice.toLowerCase() === 'c') return;
        
        const copyIdx = parseInt(copyChoice, 10) - 1;
        if (copyIdx < 0 || copyIdx >= configs.length) {
          console.log('Invalid selection');
          await this.prompt('Press Enter to continue...');
          return;
        }
        
        const sourceConfig = configs[copyIdx];
        const sourceMeta = this.configManager.loadConfiguration(sourceConfig);
        config = JSON.parse(JSON.stringify(sourceMeta.config));
        copiedFrom = sourceConfig;
        break;
      }
      case '3':
        config = JSON.parse(JSON.stringify(this.config));
        copiedFrom = this.configName;
        break;
      case '4':
        config = { google_auth: false, agents: {}, mcps: {} };
        needsSetup = true;
        break;
      default:
        console.log('Invalid option');
        await this.prompt('Press Enter to continue...');
        return;
    }

    try {
      this.configManager.saveConfiguration(name, description || 'New configuration', config);
      console.log(`\n✓ Created configuration: ${name}`);
      
      if (copiedFrom) {
        console.log(`  Copied from: ${copiedFrom}`);
      }
      
      if (needsSetup) {
        console.log('\nNote: This configuration has no agents.');
        console.log('Oh My Opencode expects agents to be configured.');
        console.log('You should add agents before using this configuration.');
      }
      
      const switchNow = await this.prompt('\nSwitch to this configuration now? (yes/no): ');
      if (switchNow.toLowerCase() === 'yes') {
        await this.switchToConfiguration(name);
        console.log(`✓ Switched to: ${name}`);
        
        // Directly enter agent configuration menu
        if (needsSetup) {
          console.log('\nLet\'s add agents to this configuration.');
          await this.prompt('Press Enter to continue...');
          await this.agentConfigMenu();
        } else {
          console.log('\nWould you like to configure agents now?');
          const configureNow = await this.prompt('(yes/no): ');
          if (configureNow.toLowerCase() === 'yes') {
            await this.agentConfigMenu();
          }
        }
      }
    } catch (error) {
      console.error(`Error: ${error.message}`);
    }
  }

  async renameConfiguration() {
    console.clear();
    console.log('\n--- Rename Configuration ---\n');

    const configs = this.configManager.listConfigurations();
    configs.forEach((name, idx) => {
      console.log(`  ${idx + 1}. ${name}`);
    });

    console.log('\n[C] Cancel\n');
    const choice = await this.prompt('Select configuration to rename: ');

    if (choice.toLowerCase() === 'c') return;

    const idx = parseInt(choice, 10) - 1;
    if (isNaN(idx) || idx < 0 || idx >= configs.length) {
      console.log('Invalid selection');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const oldName = configs[idx];
    const newName = await this.prompt('New name: ');

    if (!newName) return;

    try {
      this.configManager.renameConfiguration(oldName, newName);
      
      // Update active config if we renamed the active one
      if (oldName === this.configName) {
        this.configName = newName;
        this.configManager.setActiveConfig(newName);
      }
      
      console.log(`\n✓ Renamed "${oldName}" to "${newName}"`);
    } catch (error) {
      console.error(`Error: ${error.message}`);
    }

    await this.prompt('Press Enter to continue...');
  }

  async editDescription() {
    console.clear();
    console.log('\n--- Edit Configuration Description ---\n');

    const configs = this.configManager.listConfigurations();
    configs.forEach((name, idx) => {
      const metadata = this.configManager.loadConfiguration(name);
      console.log(`  ${idx + 1}. ${name}`);
      console.log(`     Current: ${metadata.description}\n`);
    });

    console.log('[C] Cancel\n');
    const choice = await this.prompt('Select configuration to edit: ');

    if (choice.toLowerCase() === 'c') return;

    const idx = parseInt(choice, 10) - 1;
    if (isNaN(idx) || idx < 0 || idx >= configs.length) {
      console.log('Invalid selection');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const configName = configs[idx];
    const metadata = this.configManager.loadConfiguration(configName);
    
    console.log(`\nCurrent description: ${metadata.description}`);
    const newDescription = await this.prompt('New description (or Enter to keep current): ');

    if (!newDescription) {
      console.log('No changes made');
      await this.prompt('Press Enter to continue...');
      return;
    }

    try {
      // Save with new description
      this.configManager.saveConfiguration(configName, newDescription, metadata.config);
      console.log(`\n✓ Updated description for "${configName}"`);
      
      // Update local metadata if this is the active config
      if (configName === this.configName) {
        this.configMetadata.description = newDescription;
      }
    } catch (error) {
      console.error(`Error: ${error.message}`);
    }

    await this.prompt('Press Enter to continue...');
  }

  async deleteConfiguration() {
    console.clear();
    console.log('\n--- Delete Configuration ---\n');

    const configs = this.configManager.listConfigurations();
    
    if (configs.length === 1) {
      console.log('Cannot delete the last configuration');
      await this.prompt('Press Enter to continue...');
      return;
    }

    configs.forEach((name, idx) => {
      const active = name === this.configName ? ' [ACTIVE - cannot delete]' : '';
      console.log(`  ${idx + 1}. ${name}${active}`);
    });

    console.log('\n[C] Cancel\n');
    const choice = await this.prompt('Select configuration to delete: ');

    if (choice.toLowerCase() === 'c') return;

    const idx = parseInt(choice, 10) - 1;
    if (isNaN(idx) || idx < 0 || idx >= configs.length) {
      console.log('Invalid selection');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const configName = configs[idx];
    
    if (configName === this.configName) {
      console.log('Cannot delete active configuration. Switch to another first.');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const confirm = await this.prompt(`Delete "${configName}"? This cannot be undone. (yes/no): `);
    if (confirm.toLowerCase() === 'yes') {
      try {
        this.configManager.deleteConfiguration(configName);
        console.log(`\n✓ Deleted configuration: ${configName}`);
      } catch (error) {
        console.error(`Error: ${error.message}`);
      }
    }

    await this.prompt('Press Enter to continue...');
  }

  async exportConfiguration() {
    console.clear();
    console.log('\n--- Export Configuration ---\n');

    const configs = this.configManager.listConfigurations();
    configs.forEach((name, idx) => {
      console.log(`  ${idx + 1}. ${name}`);
    });

    console.log('\n[C] Cancel\n');
    const choice = await this.prompt('Select configuration to export: ');

    if (choice.toLowerCase() === 'c') return;

    const idx = parseInt(choice, 10) - 1;
    if (isNaN(idx) || idx < 0 || idx >= configs.length) {
      console.log('Invalid selection');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const configName = configs[idx];
    const destPath = await this.prompt('Destination path (e.g., ~/my-config.json): ');

    if (!destPath) return;

    try {
      const expandedPath = destPath.replace(/^~/, process.env.HOME);
      this.configManager.exportConfiguration(configName, expandedPath);
      console.log(`\n✓ Exported "${configName}" to ${expandedPath}`);
    } catch (error) {
      console.error(`Error: ${error.message}`);
    }

    await this.prompt('Press Enter to continue...');
  }

  async importConfiguration() {
    console.clear();
    console.log('\n--- Import Configuration ---\n');

    const sourcePath = await this.prompt('Source path (e.g., ~/my-config.json): ');
    if (!sourcePath) return;

    const name = await this.prompt('Configuration name: ');
    if (!name) return;

    if (this.configManager.configExists(name)) {
      console.log('Configuration with this name already exists');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const description = await this.prompt('Description (optional): ');

    try {
      const expandedPath = sourcePath.replace(/^~/, process.env.HOME);
      this.configManager.importConfiguration(expandedPath, name, description);
      console.log(`\n✓ Imported configuration as "${name}"`);
    } catch (error) {
      console.error(`\nError importing configuration: ${error.message}`);
      if (error.code === 'ENOENT') {
        console.error(`File not found: ${sourcePath}`);
        console.error('Check the file path and try again.');
      } else if (error instanceof SyntaxError) {
        console.error('The file contains invalid JSON.');
        console.error('Ensure the file is a valid JSON configuration.');
      }
    }

    await this.prompt('Press Enter to continue...');
  }

  async agentConfigMenu() {
    while (true) {
      console.clear();
      console.log('\n--- Configure Agents ---\n');
      
      const agents = Object.entries(this.config.agents || {});
      
      if (agents.length === 0) {
        console.log('No agents configured\n');
      } else {
        console.log('CURRENT AGENTS:\n');
        agents.forEach(([name, config], idx) => {
          console.log(`  ${idx + 1}. ${name.padEnd(30)} → ${config.model}`);
        });
      }
      
      console.log('\nOPTIONS:\n');
      console.log('  [E] Edit agent model (enter number or name)');
      console.log('  [D] Delete agent (enter number or name)');
      console.log('  [?] Show agent information');
      console.log('  [B] Back to main menu');
      
      console.log('\nCapabilities: [R]=Reasoning [I]=Image [P]=PDF\n');
      
      const choice = await this.prompt('Select option: ');
      
      switch (choice.toLowerCase()) {
        case 'e': {
          const agentInput = await this.prompt('Agent # or name: ');
          
          const agentIdx = parseInt(agentInput, 10) - 1;
          let agentName = null;
          
          if (!isNaN(agentIdx) && agentIdx >= 0 && agentIdx < agents.length) {
            agentName = agents[agentIdx][0];
          } else if (this.config.agents[agentInput]) {
            agentName = agentInput;
          }
          
          if (agentName) {
            await this.editAgent(agentName, true);  // fromMenu = true
          } else {
            console.log('Agent not found');
            await this.prompt('Press Enter to continue...');
          }
          break;
        }
        case 'd': {
          const agentInput = await this.prompt('Agent # or name: ');
          
          const agentIdx = parseInt(agentInput, 10) - 1;
          let agentName = null;
          
          if (!isNaN(agentIdx) && agentIdx >= 0 && agentIdx < agents.length) {
            agentName = agents[agentIdx][0];
          } else if (this.config.agents[agentInput]) {
            agentName = agentInput;
          }
          
          if (agentName) {
            await this.deleteAgent(agentName, true);  // fromMenu = true
          } else {
            console.log('Agent not found');
            await this.prompt('Press Enter to continue...');
          }
          break;
        }
        case '?':
          await this.showAgentInfo();
          break;
        case 'b':
          return;
        default:
          console.log('Invalid option');
          await this.prompt('Press Enter to continue...');
      }
    }
  }

  async setPreferredProviders() {
    console.clear();
    console.log('\n--- Set Preferred Providers ---\n');
    
    const currentPreferred = this.config.preferred_providers || [];
    
    if (currentPreferred.length > 0) {
      console.log('CURRENT PREFERRED PROVIDERS:\n');
      currentPreferred.forEach((provider, idx) => {
        console.log(`  ${idx + 1}. ${provider}`);
      });
      console.log('');
    }
    
    console.log('AVAILABLE PROVIDERS:\n');
    this.providers.forEach((provider, idx) => {
      const count = this.models.filter(m => (m.providerID || m.id.split('/')[0]) === provider).length;
      const preferred = currentPreferred.includes(provider) ? ' (preferred)' : '';
      console.log(`  ${idx + 1}. ${provider} (${count} models)${preferred}`);
    });

    console.log('\n[X] Clear preferences');
    console.log('[B] Back\n');
    
    const choice = await this.prompt('Select providers (comma-separated numbers) or action: ');
    
    if (choice.toLowerCase() === 'b') {
      return;
    }

    if (choice.toLowerCase() === 'x') {
      delete this.config.preferred_providers;
      this.saveConfig();
      console.log('✓ Cleared preferred providers');
      await this.prompt('Press Enter to continue...');
      return;
    }

    const indices = choice.split(',').map(s => parseInt(s.trim(), 10) - 1).filter(n => !isNaN(n));
    const selectedProviders = indices
      .filter(idx => idx >= 0 && idx < this.providers.length)
      .map(idx => this.providers[idx]);

    if (selectedProviders.length === 0) {
      console.log('No providers selected');
      await this.prompt('Press Enter to continue...');
      return;
    }

    this.config.preferred_providers = selectedProviders;
    this.saveConfig();
    console.log(`✓ Set preferred providers: ${selectedProviders.join(', ')}`);
    await this.prompt('Press Enter to continue...');
  }

  async mainMenu() {
    while (true) {
      console.clear();
      console.log('\n' + '='.repeat(70));
      console.log('Oh My Opencode - Agent Configuration');
      console.log('='.repeat(70));
      
      // Show active configuration
      const modDate = new Date(this.configMetadata.modified).toLocaleDateString();
      console.log(`\nActive Configuration: ${this.configName}`);
      console.log(`Description: ${this.configMetadata.description}`);
      console.log(`Modified: ${modDate}\n`);

      console.log('CURRENT AGENTS:\n');
      const agents = Object.entries(this.config.agents || {});
      
      if (agents.length === 0) {
        console.log('  No agents configured\n');
      } else {
        agents.forEach(([name, config], idx) => {
          console.log(`  ${idx + 1}. ${name.padEnd(30)} → ${config.model}`);
        });
      }

      console.log('\nACTIONS:\n');
      console.log('  [E] Edit agent model (enter number or name)');
      console.log('  [D] Delete agent (enter number or name)');
      console.log('  [?] Show agent information');
      console.log('  [P] Set preferred providers');
      console.log('  [U] Update config (sync with OmO defaults)');
      console.log('  [M] Manage configurations');
      console.log('  [R] Restore defaults');
      console.log('  [B] View backups');
      console.log('  [Q] Quit');
      
      // Capability legend
      console.log('\nCapabilities: [R]=Reasoning [T]=Thinking [I]=Image [P]=PDF [F]=Fast');
      console.log('Managing OmO built-in agents only (see [?] for custom agents)\n');
      
      const choice = await this.prompt('Select option: ');
      
      switch (choice.toLowerCase()) {
        case 'e': {
          const agentInput = await this.prompt('Agent # or name: ');
          
          // Check if it's a number
          const agentIdx = parseInt(agentInput, 10) - 1;
          let agentName = null;
          
          if (!isNaN(agentIdx) && agentIdx >= 0 && agentIdx < agents.length) {
            agentName = agents[agentIdx][0];
          } else if (this.config.agents[agentInput]) {
            agentName = agentInput;
          }
          
          if (agentName) {
            await this.editAgent(agentName);
          } else {
            console.log('Agent not found');
            await this.prompt('Press Enter to continue...');
          }
          break;
        }
        case 'd': {
          const agentInput = await this.prompt('Agent # or name: ');
          
          // Check if it's a number
          const agentIdx = parseInt(agentInput, 10) - 1;
          let agentName = null;
          
          if (!isNaN(agentIdx) && agentIdx >= 0 && agentIdx < agents.length) {
            agentName = agents[agentIdx][0];
          } else if (this.config.agents[agentInput]) {
            agentName = agentInput;
          }
          
          if (agentName) {
            await this.deleteAgent(agentName);
          } else {
            console.log('Agent not found');
            await this.prompt('Press Enter to continue...');
          }
          break;
        }
        case '?':
          await this.showAgentInfo();
          break;
        case 'p':
          await this.setPreferredProviders();
          break;
        case 'u':
          await this.promptConfigSync();
          break;
        case 'm':
          await this.manageConfigurationsMenu();
          break;
        case 'r': {
          const confirm = await this.prompt('Restore all agents to defaults? (yes/no): ');
          if (confirm.toLowerCase() === 'yes') {
            await this.restoreDefaults();
            await this.prompt('Press Enter to continue...');
          }
          break;
        }
        case 'b':
          await this.viewBackups();
          break;
        case 'q':
          this.rl.close();
          console.log('\nGoodbye!\n');
          return;
        default:
          console.log('Invalid option');
          await this.prompt('Press Enter to continue...');
      }
    }
  }

  async viewBackups() {
    console.clear();
    console.log('\n--- Configuration Backups ---\n');
    
    try {
      const allFiles = fs.readdirSync(BACKUP_DIR)
        .filter(f => f.endsWith('.json'))
        .sort()
        .reverse();
      
      // Filter for current config
      const currentConfigFiles = allFiles.filter(f => f.startsWith(`${this.configName}-`));
      
      console.log(`Backups for "${this.configName}":\n`);
      if (currentConfigFiles.length === 0) {
        console.log('  No backups found for this configuration');
      } else {
        currentConfigFiles.slice(0, 10).forEach((file, idx) => {
          const stats = fs.statSync(path.join(BACKUP_DIR, file));
          console.log(`  ${idx + 1}. ${file} (${stats.size} bytes)`);
        });
      }
      
      // Show option to view all backups
      const otherFiles = allFiles.filter(f => !f.startsWith(`${this.configName}-`));
      if (otherFiles.length > 0) {
        console.log(`\nOther configurations have ${otherFiles.length} backup(s)`);
        const showAll = await this.prompt('Show all backups? (yes/no): ');
        
        if (showAll.toLowerCase() === 'yes') {
          console.clear();
          console.log('\n--- All Configuration Backups ---\n');
          allFiles.slice(0, 20).forEach((file, idx) => {
            const stats = fs.statSync(path.join(BACKUP_DIR, file));
            console.log(`  ${idx + 1}. ${file} (${stats.size} bytes)`);
          });
        }
      }
      
      // Option to restore from backup
      if (currentConfigFiles.length > 0 || allFiles.length > 0) {
        console.log('');
        const restore = await this.prompt('Restore from backup? (yes/no): ');
        if (restore.toLowerCase() === 'yes') {
          await this.restoreFromBackup(currentConfigFiles, allFiles);
        }
      }
    } catch (error) {
      console.log(`Error reading backups: ${error.message}`);
    }
  }

  async restoreFromBackup(currentConfigFiles, allFiles) {
    console.clear();
    console.log('\n--- Restore from Backup ---\n');
    
    // Ask which scope
    console.log('Restore from:\n');
    console.log('  [1] Current configuration backups');
    console.log('  [2] All backups');
    console.log('  [C] Cancel\n');
    
    const scope = await this.prompt('Select option: ');
    if (scope.toLowerCase() === 'c') return;
    
    const files = scope === '2' ? allFiles : currentConfigFiles;
    
    if (files.length === 0) {
      console.log('No backups available');
      await this.prompt('Press Enter to continue...');
      return;
    }
    
    console.clear();
    console.log('\n--- Select Backup to Restore ---\n');
    
    files.slice(0, 20).forEach((file, idx) => {
      const stats = fs.statSync(path.join(BACKUP_DIR, file));
      const date = file.match(/\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}/)?.[0] || '';
      console.log(`  ${idx + 1}. ${file}`);
      console.log(`      ${new Date(date.replace('T', ' ').replace(/-/g, ':')).toLocaleString()} (${stats.size} bytes)\n`);
    });
    
    console.log('[C] Cancel\n');
    const choice = await this.prompt('Select backup: ');
    
    if (choice.toLowerCase() === 'c') return;
    
    const idx = parseInt(choice, 10) - 1;
    if (isNaN(idx) || idx < 0 || idx >= files.length) {
      console.log('Invalid selection');
      await this.prompt('Press Enter to continue...');
      return;
    }
    
    const backupFile = files[idx];
    const backupPath = path.join(BACKUP_DIR, backupFile);
    
    // Extract config name from filename
    const configName = backupFile.split('-202')[0];  // Get everything before the timestamp
    
    try {
      // Load backup data
      const backupData = JSON.parse(fs.readFileSync(backupPath, 'utf8'));
      
      // Show preview
      console.clear();
      console.log('\n--- Backup Preview ---\n');
      console.log(`Configuration: ${configName}`);
      console.log(`Backup file: ${backupFile}`);
      
      const backupConfig = backupData.config || backupData;
      const agentCount = Object.keys(backupConfig.agents || {}).length;
      console.log(`\nAgents in backup: ${agentCount}`);
      
      if (agentCount > 0) {
        console.log('\nAgents:');
        Object.entries(backupConfig.agents).forEach(([name, config]) => {
          console.log(`  - ${name} → ${config.model}`);
        });
      }
      
      console.log('\n⚠️  Warning: This will replace the current configuration!');
      console.log('A backup of the current state will be created first.\n');
      
      const confirm = await this.prompt('Proceed with restore? (yes/no): ');
      
      if (confirm.toLowerCase() === 'yes') {
        // Create backup of current state
        this.createBackup();
        
        // Restore from backup
        const description = backupData.description || `Restored from ${backupFile}`;
        this.configMetadata = this.configManager.saveConfiguration(
          this.configName,
          description,
          backupConfig
        );
        this.config = backupConfig;
        this.configManager.updateMainConfigFile(this.config);
        
        console.log(`\n✓ Successfully restored from backup`);
        console.log(`  Configuration: ${this.configName}`);
        console.log(`  Agents: ${agentCount}`);
      } else {
        console.log('Restore cancelled');
      }
    } catch (error) {
      console.error(`\nError restoring backup: ${error.message}`);
    }
    
    await this.prompt('\nPress Enter to continue...');
  }

  async run() {
    console.log('\nOh My Opencode Agent Configuration Tool\n');
    
    await this.loadConfig();
    await this.loadModels();
    
    // Check for missing agents/MCPs and offer to sync
    await this.promptConfigSync();
    
    await this.mainMenu();
  }

  async handleCliArgs(args) {
    const command = args[0];

    switch (command) {
      case '--help':
      case '-h':
        this.showHelp();
        process.exit(0);
        break;

      case '--list':
      case '-l':
        await this.loadConfig();
        this.listConfigsCli();
        process.exit(0);
        break;

      case '--current':
      case '-c':
        await this.loadConfig();
        this.showCurrentCli();
        process.exit(0);
        break;

      case '--switch':
      case '-s':
        if (!args[1]) {
          console.error('Error: Configuration name required');
          console.log('Usage: opencode-agent-config --switch <config-name>');
          process.exit(1);
        }
        await this.loadConfig();
        await this.switchConfigCli(args[1]);
        process.exit(0);
        break;

      default:
        if (command && command.startsWith('-')) {
          console.error(`Error: Unknown option '${command}'`);
          console.log('Use --help to see available options');
          process.exit(1);
        }
        // No args or unrecognized args, run interactive mode
        await this.run();
    }
  }

  showHelp() {
    console.log(`
Oh My Opencode Agent Configuration Tool

USAGE:
  opencode-agent-config [OPTIONS]

OPTIONS:
  -h, --help              Show this help message
  -l, --list              List all configurations
  -c, --current           Show current active configuration
  -s, --switch <name>     Switch to specified configuration

EXAMPLES:
  opencode-agent-config                    # Run interactive mode
  opencode-agent-config --list             # List all configurations
  opencode-agent-config --switch work      # Switch to 'work' config
  opencode-agent-config -s omo-default     # Switch to default config
`);
  }

  listConfigsCli() {
    const configs = this.configManager.listConfigurations();
    
    console.log('AVAILABLE CONFIGURATIONS:\n');
    configs.forEach(name => {
      const metadata = this.configManager.loadConfiguration(name);
      const active = name === this.configName ? ' [ACTIVE]' : '';
      const modDate = new Date(metadata.modified).toLocaleDateString();
      const agentCount = Object.keys(metadata.config.agents || {}).length;
      console.log(`  ${name}${active} (${agentCount} agents)`);
      console.log(`  ${metadata.description}`);
      console.log(`  Modified: ${modDate}\n`);
    });
  }

  showCurrentCli() {
    const modDate = new Date(this.configMetadata.modified).toLocaleDateString();
    console.log(`Active Configuration: ${this.configName}`);
    console.log(`Description: ${this.configMetadata.description}`);
    console.log(`Modified: ${modDate}`);
    
    const agentCount = Object.keys(this.config.agents || {}).length;
    console.log(`\nAgents configured: ${agentCount}`);
  }

  async switchConfigCli(configName) {
    if (!this.configManager.configExists(configName)) {
      console.error(`Error: Configuration "${configName}" does not exist`);
      console.log('\nAvailable configurations:');
      const configs = this.configManager.listConfigurations();
      configs.forEach(name => console.log(`  - ${name}`));
      process.exit(1);
    }

    try {
      await this.switchToConfiguration(configName);
      console.log(`✓ Switched to configuration: ${configName}`);
      
      const agentCount = Object.keys(this.config.agents || {}).length;
      console.log(`  Agents: ${agentCount}`);
    } catch (error) {
      console.error(`Error switching configuration: ${error.message}`);
      process.exit(1);
    }
  }
}

// Parse CLI arguments and run
const args = process.argv.slice(2);
const tool = new AgentConfigTool();

if (args.length > 0) {
  tool.handleCliArgs(args).catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
} else {
  tool.run().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}
